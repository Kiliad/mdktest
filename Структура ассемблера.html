<!DOCTYPE html>
<html>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="zoom.css" rel="stylesheet" type="text/css">
<meta charset="utf-8">
	<head>
		<link rel="shortcut icon" href="Multimedia/prosessor.ico" type="image/x-icon">
	</head>
	<title>Структура ассемблера</title>
		<body class="avtmilf">
		<article>
  <header>
    <h1 class="shadowtext">Структура ассемблера</h1>
      </font>
	<a href="index.html" class="button">Главная</a>	</font>
     </header>
</article>
<div class="div">
	<h1>Организация ассемблерной программы</h1>
			<p>Пользовательская (прикладная) программа, написанная для платформ IA-32/Linux
			или IA-32/Windows, рассчитана на выполнение в машине, реализующей принципы 
			фон Неймана (Рис. 1). Машинные команды и данные хранятся совместно в 
			оперативной памяти, а процессор в автоматическом режиме последовательно 
			читает из памяти команды и исполняет их. Оперативная память разбита на ячейки
			размером по 8 двоичных разрядов (1 байт), ячейки пронумерованы числами от 0
			до 2
			32
			-1 (номер ячейки называют ее адресом). Процессор содержит набор 32-х 
			разрядных регистров, состоящий из восьми регистров общего назначения, счетчика 
			команд, регистра состояния. Взаимодействие процессором с оперативной памятью 
			осуществляется через шину, позволяющей процессору считывать значения ячеек 
			оперативной памяти, записывать в ячейки новые значения.</p>
				<p class="pic"><img src=Multimedia/stras.jpg size="350">
			<p>Программа, которая готова к исполнению процессором, представляет собой 
			определенный набор значений ячеек оперативной памяти. Эти значения заносит в 
			оперативную память загрузчик — компонент операционной системы, отвечающий 
			за загрузку исполняемого файла (копирование его содержимого) в память. Для 
			формирования исполняемого файла используются инструменты системы 
			программирования; основными инструментами являются компилятор, ассемблер, 
			компоновщик</p>
			<p>Машина IA-32 позволяет обращаться к произвольному месту оперативной памяти, 
			однако не все ячейки доступны, обращения к одним адресам завершатся успешно, 
			к другим – приведут к аварийной остановке программы. Причиной является то, что 
			пользовательская программа работает в защищенном режиме процессора: 
			фактически ей доступны только определенные диапазоны адресов, содержащие 
			8
			образ программы в памяти. Управление памятью, доступной пользовательской 
			программе, осуществляет операционная система, этот вопрос выходит за рамки 
			данного курса.</p>
				<p class="pic"><img src=Multimedia/sxkom.jpg size="350">
					<p>В простых программах набор секций, как правило, ограничен тремя (не считая 
			служебных): </p>
					<li>секция кода, которая обычно называется .text;</li>
					<li>секция инициализированных данных (то есть тех, для которых определено 
					начальное значение), которая обычно называется .data</li>
					<li>секция неинициализированных данных, значения которых обнуляются 
					операционной системой перед запуском программы; эта секция обычно 
					называется .bss.</li>
			<p>В ассемблерном файле могут присутствовать и другие секции. Например, может 
			быть несколько секций кода или данных, однако мы такие программы 
			рассматривать не будем. Программа воспринимается построчно. Каждая строка,
			как и во многих других ассемблерах, представляет собой последовательность 
			следующих полей</p>
					<li>метка — присваивает имя данному месту в программе, вне зависимости от 
					того, что на этом месте расположено (код/данные);
					</li>
					<li>ассемблерная инструкция, состоит из кода операции и операндов (если они 
					есть), перечисляемых через запятую;</li>
					<li>директива определения данных;</li>
					<li>комментарий.</li>
			<p>Допустимы пустые строки. Кроме того, на отдельных строках могут быть записаны 
			служебные директивы, указывающие ассемблеру, каким образом следует 
			размещать код и данные в памяти</p>
		<h2>Ассемблерная инструкция</h2>
			<p>Строка с описанием ассемблерной инструкции имеет следующий вид:</p>
				<p class="snoska">метка: код_опреации операнды ; комментарий</p>
			<p>Имена меток не должны повторяться (за исключением локальных меток, которые 
			будут рассмотрены во второй части пособия). Допустима ситуация, когда 
			ассемблерная инструкция пропущена и строка содержит только метку с 
			двоеточием. Такое форматирование текста практикуют для лучшей читаемости 
			ассемблерного кода. Инструкция отделяется от операндов одним или несколькими 
			пробелами или символами табуляции, а операнды, если они есть, должны быть 
			метка: код_опреации операнды ; комментарий
			10
			отделены друг от друга запятыми и, возможно, пробельными символами и 
			символами табуляции. В конце строки может находиться комментарий, 
			начинающийся с символа «точка с запятой». Комментарий продолжается до конца 
			строки. </p>
		<h2>Директивы определения данных</h2>
			<p>Строка с описанием данных имеет следующий вид:</p>
			<p class="snoska">имя_переменной [:] директива_определения_данных ; комментарий</p>
			<p>При описании данных, после имени переменной может присутствовать двоеточие; 
			фактическое использование ассемблером символьного имени переменной в 
			точности совпадает с использованием меток, помечающих код.</p>
			<p>Для определения переменных с начальными значениями используются директивы DB, DW, DD и DQ. Например:</p>
			<p class="snoska">имя_переменной DD значение1[, значение2, ... ]</p>
			<p>Директива DB предназначена для определения данных размером в байт, DW, DD и 
			DQ определяют данные размером соответственно в слово (2 байта), двойное слово 
			(4 байта) и учетверенное слово (8 байтов). Например:</p>
			<p class="snoska">x dw -1 ; Определение переменной x в формате слова с начальным значением -1<br><br>y dd 1, 2, 3 ; Определение трех двойных слов с начальными значениями 1, 2, 3</p>
			<p>Последняя директива описывает тот факт, что в памяти, начиная с адреса у, 
			последовательно размещаются три двойных слова с указанными значениями, при 
			этом первое двойное слово располагается в памяти по адресу y, второе – по адресу 
			y+4, третье – по адресу y+8. </p>
			<p>В общем случае, через запятую перечисляется набор значений, который будет 
			размещен в памяти, начиная с адреса, помеченного как имя_переменной.</p>
			<p>NASM не позволяет указывать неопределенное начальное значение (в MASMe для 
			этого служил знак ?). Если начальное значение переменной не важно, ее следует 
			располагать в секции .bss, все байты которой инициализируются нулем. Такая 
			особенность позволяет экономить место в файле с исполняемым кодом: 
			содержимое секции заранее известно, достаточно хранить только ее размер. При 
			x dw -1 ; Определение переменной x в формате слова с 
			 ; начальным значением -1
			y dd 1, 2, 3 ; Определение трех двойных слов с начальными 
			 ; значениями 1, 2, 3
			имя_переменной DD значение1[, значение2, ... ]
			имя_переменной [:] директива_определения_данных ; комментарий
			11
			объявлении переменных в секции .bss необходимо использовать 
			соответствующие директивы: RESB, RESW, RESD и RESQ, имеющие следующий 
			формат. </p>
			<p class="snoska">имя_переменной RESB количество_ячеек </p>
			<p>Под количеством ячеек понимается число байт, слов, двойных или четверных слов, 
			в зависимости от использованной директивы.</p>
			<p class="snoska">a resd 1 ; Выделено место для одной переменной, ее размер – двойное слово, начальное значения – 0<br><br>
			b resb 20 ; Выделено место для последовательно размещенных 20 байт<br><br>
			c resw 256 ; Выделено место для 256 слов</p>
			<p>Имена a, b и c являются адресами, начиная с которых размещены обнуленные данные.</p>
			<p>В качестве конструкции повторения в ассемблере NASM используется префикс TIMES (в отличие от DUP в MASMe):</p>
			<p class="snoska">TIMES количество_раз повторяемая конструкция</p>
			<p>Пример – требуется объявить переменную с именем zerobuf, представляющую собой буфер размером в 64 байта и заполненный нулями. </p>
			<p class="snoska">zerobuf times 64 db 0</p>
		<h2>Константы</h2>
			<p>Ассемблер  NASM поддерживает  несколько  типов  констант:  целочисленные, символы, строки и числа с плавающей точкой. </p>
			<p>У целочисленных констант поддерживаются различные основания: десятичное, 
			двоичное,  восьмеричное,  шестнадцатеричное.  Для  явного  задания  основания 
			следует воспользоваться соответствующими суффиксами: d, b или y, o или q, h. По-
			умолчанию  последовательность  цифр  рассматривается  как  десятичное  число. 
			Помимо  того,  допустимы  формы  задания  основания  в  виде  префиксов:  0d – 
			десятичное  0b – двоичное, 0o – восьмеричное,  0h – шестнадцатеричное. 
			Допускается запись шестнадцатеричных чисел как в Си-программах, с префиксом 
			0x.</p>
			<p>Целочисленные  константы  могут  содержать  символ  подчеркивания  для 
			разделения длинных последовательностей цифр.  </p>
			<p class="snoska">mov     ax,200          ; десятичное <br><br>
			mov     ax,0200d        ; явно указанное десятичное <br><br>
			mov     ax,0c8h         ; шестнадцатеричное  <br><br>
 			mov     ax,0xc8         ; шестнадцатеричное <br><br>
 			mov     ax,310q         ; восьмеричное   <br><br>
 			mov     ax,11001000b    ; двоичное   <br><br>
 			mov     ax,1100_1000b   ; двоичное </p>
 			<p>Во всех случаях приведен один и тот же код.  </p>
 			<p>Символьная константа содержит от одного до восьми  символов, заключенных в 
			прямые,  обратные или двойные кавычки. Тип кавычек для NASM несущественен, 
			поэтому если используются одинарные кавычки, двойные могут выступать в роли 
			символа и, соответственно, наоборот.  Обратные кавычки позволяют использовать 
			специальные символы языка Си.  </p>
			<p>Символьная константа, состоящая из одного символа, эквивалентна целому числу, 
			равному коду этого символа. Символьная константа, содержащая более одного 
			символа,  будет  транслирована  посимвольно  в  обратном  порядке  следования 
			байтов:  'abcd'  эквивалентно  не  0x61626364,  а  0x64636261.  Эта  особенность 
			обусловлена порядком хранения байтов целого числа в памяти:  сначала хранятся  
			младшие байты, за ними — старшие. Таким образом, если записать эту константу в 
			память, а затем прочитать побайтово, получится снова abcd, но не dcba.  </p>
			<p>Строковые константы допустимы только в директивах db/dw/dd/dq. От символьных 
			констант  они  отличаются  только  отсутствием  ограничения  на  длину  и интерпретируются  как  сцепленные  друг  с  другом  символьные  константы максимального допустимого размера.  </p>
			<p class="snoska">dd 'ninechars'       ; строковая константа – последовательность  двойных слов <br><br>
			dd 'nine','char','s' ; явно заданы три двойных слова <br><br>
			db 'ninechars',0,0,0 ; последовательность байт </p>
			<p>Во всех случаях определены одни и те же данные.  </p>
		<h2>Классы памяти  </h2>
			<p>В  стандарте  языка  Си  определены  три  класса  памяти  (storage duration): 
			статическая,  автоматическая,  динамическая.  К  статическому  классу  памяти 
			относятся  глобальные  и  статические  переменные.  В  зависимости  от  того,  как 
			выполняется  инициализация,  переменные  этого  класса  помещаются 
			компилятором либо в секцию .data, либо в секцию .bss.  Такие вопросы, как 
			размещение  автоматических  локальных  переменных  и  работа  с  динамической 
			памятью, в этой части пособия не рассматриваются.  </p>
	</div>
<a href="#" class="scrollup">Наверх</a>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="script.js"></script>
<script src="zoom.js"></script>
	</body>
</html>
