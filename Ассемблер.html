<!DOCTYPE html>
<html>
<link href="style.css" rel="stylesheet" type="text/css">
<meta charset="utf-8">
	<head>
		<link rel="shortcut icon" href="Multimedia/prosessor.ico" type="image/x-icon">
	</head>
	<title>Ассемблер</title>
		<body class="sokr">
		<article>
  <header>
    <h1 class="shadowtext">Ассемблер</h1>
      </font>
	<a href="index.html" class="button">Главная</a>	</font>
     </header>
</article>
<div class="div">
	<p>Язы́к ассе́мблера (англ. assembly language) — машинно-ориентированный язык программирования низкого уровня. Представляет собой систему обозначений, используемую для представления в удобно читаемой форме программ, записанных в машинном коде. Его команды прямо соответствуют отдельным командам машины или их последовательностям. Является существенно платформо-зависимым: языки ассемблера для различных аппаратных платформ несовместимы, хотя могут быть в целом подобны.</p>
	            <p class="pic"><img src="Multimedia/assembler.png" align="center" size="800" height="800" title="Листинг программы на языке ассемблера Motorola MC6800 (слева идут адреса и машинные коды в шестнадцатеричной системе, вычисленные и сгенерированные ассемблером из исходного кода программы, справа показан сам текст программы с мнемоническими инструкциями, метками, директивами, выражениями и комментариями)" /></p>
	<p>Язык ассемблера позволяет программисту пользоваться алфавитными мнемоническими кодами операций, по своему усмотрению присваивать символические имена регистрам ЭВМ и памяти, а также задавать удобные для себя схемы адресации (например, индексную или косвенную). Кроме того, он позволяет использовать различные системы счисления (например, десятичную или шестнадцатеричную) для представления числовых констант и даёт возможность помечать строки программы метками с символическими именами с тем, чтобы к ним можно было обращаться (по именам, а не по адресам) из других частей программы (например, для передачи управления).</p>
	<p>Также может предоставлять дополнительные возможности облегчения программирования, такие как макрокоманды, выражения, средства обеспечения модульности программ. В связи с этим может рассматриваться как автокод (см. ниже), расширенный конструкциями языков программирования высокого уровня</p>
	<p>Перевод программы на языке ассемблера в исполнимый машинный код (вычисление выражений, раскрытие макрокоманд, замена мнемоник собственно машинными кодами и символьных адресов на абсолютные или относительные адреса) производится ассемблером — программой-транслятором, которая и дала языку ассемблера его название.</p>
	<p>В разговорном русском языке может именоваться просто «ассемблером» (типичны выражения типа «писать программу на ассемблере»), что, строго говоря, неверно, так как ассемблером именуется утилита трансляции программы с языка ассемблера в машинный код процессора. Вместо фразы «программа на ассемблере» корректнее говорить «программа на языке ассемблера».</p>
	<p>Использование термина «язык ассемблера» может вызвать ошибочное мнение о существовании некоего единого языка низкого уровня или хотя бы стандарта на такой язык. Поскольку синтаксис программы на языке ассемблера зависит главным образом от используемой архитектуры, единого языка ассемблера не существует. При использовании термина «язык ассемблера», если не очевидно из контекста, желательно уточнять, ассемблер для какой архитектуры имеется в виду.</p>
		<h1>Синтаксис языка</h1>
	<p>Синтаксис программы на языке ассемблера определяется главным образом системой команд конкретного процессора и системой директив конкретного транслятора.</p>
	<p>Для некоторых платформ может существовать несколько видов синтаксиса языка ассемблера, не совместимых между собой. Например, наиболее популярные синтаксисы языков ассемблера для Intel-совместимых процессоров — Intel-синтаксис и AT&T-синтаксис.</p>
		<h2>Метки</h2>
	<p>Язык ассемблера позволяет использовать символические метки вместо адресов ячеек памяти, которые при ассемблировании заменяются на вычисляемые ассемблером или компоновщиком абсолютные или относительные адреса.</p>
	<p>В большинстве случаев имя метки в тексте программы записывают, начиная с первой позиции текстовой строки, и отделяют от остального текста двоеточием:</p>
	<p class="brd">Label1:</p>
	<p>На объявленную затем метку может быть выполнен переход из другого места программы, расположенного как выше, так и ниже по тексту.</p>
		<h2>Запись числовых констант</h2>
	<p>Трансляторы с языка ассемблера позволяют использовать числовые константы в различных системах счисления, поэтому для каждой используемой в тексте программы числовой константы должно быть указано, в какой системе счисления она записана. Способы указания систем счисления зависят от конкретного транслятора и могут существенно отличаться от одного транслятора к другому. Например:</p>
			<li>Для записи числа в десятичной системе счисления в одних трансляторах требуется представление только в виде цифр (255, 65535), тогда как в других для этого требуется начать число с точки (.255, .65535).</li>
			<li>Для записи числа в шестнадцатеричной системе требуется начать число с префикса «0x» (0xFF, 0x2000), в других — добавить в конце числа «h» (0FFh, 2000h), в третьих — записывать только цифры (0FF, 2000), при этом в последних двух случаях у чисел, начинающиеся с A…F, для отличия их от символьных имён спереди добавляют ноль.</li>
			<li>Признаком восьмеричной системы в некоторых трансляторах является ведущий ноль (0377, 0177777), в других требуется добавить префикс в виде буквы «O», а число заключить в апострофы (O’377’, O’177777’).</li>
			<li>Для записи констант в двоичной системе распространённым является формат вида b'10010111'.</li>
	<p>Соответственно, запись числа без явного указания системы счисления разными трансляторами будет воспринята по-разному. Например, 057 в зависимости от транслятора может быть прочитано как восьмеричная запись числа 47, десятичная запись числа 57 или шестнадцатеричная запись числа 87. В некоторых трансляторах система счисления, используемая по умолчанию, может быть определена с помощью директив.</p>
		<h2>Инструкции процессора</h2>
	<p>Команды языка ассемблера один к одному соответствуют командам процессора. Фактически, они и представляют собой более удобную для человека символьную форму записи — мнемокоды — команд и их аргументов. При этом одной команде языка ассемблера может соответствовать несколько вариантов команд процессора</p>
	<p>Каждая модель (или семейство) процессоров имеет свой набор команд (систему команд) и соответствующий ей язык ассемблера. Используемые мнемоники обычно одинаковы для всех процессоров одной архитектуры или семейства архитектур (среди широко известных — мнемоники процессоров и контроллеров x86, ARM, PIC, SPARC, PowerPC, M68k и другие). Возможные исключения из этого правила:</p>
			<li>Если ассемблер использует кроссплатформенный AT&T-синтаксис (оригинальные мнемоники приводятся к синтаксису AT&T). Так, различия между синтаксисом Intel и AT&T касаются в основном порядка перечисления операндов и указания различных методов адресации.</li>
			<li>Если изначально существовало два стандарта записи мнемоник (система команд была унаследована от процессора другого производителя). Например, процессор Zilog Z80 унаследовал систему команд Intel 8080, расширил её и поменял мнемоники (и обозначения регистров) на свой лад. Процессоры Motorola Fireball унаследовали систему команд Z80, несколько её сократив. Вместе с тем, Motorola официально вернулась к мнемоникам Intel и в данный момент половина ассемблеров для Fireball работает с мнемониками от Intel, а половина — с мнемониками от Zilog.</li>
	<p>Типичными командами языка ассемблера являются (большинство примеров даны для Intel-синтаксиса архитектуры x86):</p>
			<li>Команды пересылки данных (mov и др.)</li>
			<li>Арифметические команды (add, sub, imul и др.)</li>
			<li>Логические и побитовые операции (or, and, xor, shr и др.)</li>
			<li>Команды управления ходом выполнения программы (jmp, loop, ret и др.)</li>
			<li>Команды вызова прерываний (иногда относят к командам управления): int</li>
			<li>Команды ввода-вывода в порты (in, out)</li>
			<li>Для микроконтроллеров и микрокомпьютеров характерны также команды, выполняющие проверку и переход по условию, например некоторые из них:</li>
		<ul>
			<li>cjne — перейти, если не равно</li>
			<li>djnz — декрементировать, и если результат ненулевой, то перейти</li>
			<li>cfsneq — сравнить, и если не равно, пропустить следующую команду</li>
		</ul>
	<p>Наборы мнемоник конкретных процессоров описаны в спецификациях этих процессоров, часто известных как «Datasheet».</p>
	<p>Типичный формат записи команд:</p>
	<p class="brd">[метка:] [ [префикс] мнемокод [операнд {, операнд}] ] [;комментарий]</p>
	<p>В указанном формате строки:</p>
			<li>Метка — символьное имя, обозначающее адрес в памяти программ, по которому расположена данная инструкция. Если в строке с меткой не содержится мнемокод, метка обычно будет относиться к следующему мнемокоду, расположенному ниже по тексту программы.</li>
			<li>Мнемокод — непосредственно мнемоника инструкции процессору. Большинство трансляторов предусматривает размещение в одной строке мнемокода только одной инструкции процессора.</li>
			<li>К мнемокоду могут быть добавлены префиксы (повторения, изменения типа адресации и пр.). Возможные префиксы, также как и набор мнемоник, определяются архитектурой процессора. Некоторые процессоры не поддерживают префиксы.</li>
			<li>В качестве операндов могут выступать константы, адреса регистров, адреса в оперативной памяти и пр. Набор операндов, которые можно передать той или иной мнемонике, также определяется архитектурой процессора.</li>
			<li>Комментарий — произвольный текст, не выполняемый транслятором и служащий для пояснений выполняемых действий программистам. Допускается, что в строке не присутствует ничего кроме комментария.</li>
	<P>Пример кодирования инструкций на языке ассемблера для архитектуры PIC16:</P>
		            <p class="pic"><img src="Multimedia/kod.jpg" align="center" size="125" height="125" title="" /></p>
		<h1>TASM</h1>
	<p>Turbo Assembler (TASM) — программный пакет компании Borland, предназначенный для разработки программ на языке ассемблера для архитектуры x86. Кроме того, TASM может работать совместно с трансляторами с языков высокого уровня фирмы Borland, такими как Turbo C и Turbo Pascal. Как и прочие программные пакеты серии Turbo, TASM больше не поддерживается.</p>
	<p>Пакет TASM поставляется вместе с компоновщиком Turbo Linker и создаёт объектный .obj-файл, который компоновщик переводит в исполнимый файл. Полученные исполнимые файлы можно отлаживать с помощью Turbo Debugger.</p>
	<p>По умолчанию TASM работает в режиме совместимости с другим распространённым ассемблером — Microsoft Macro Assembler, то есть TASM умеет транслировать исходники, разработанные под MASM. Кроме того, TASM имеет режим IDEAL, улучшающий синтаксис языка и расширяющий его функциональные возможности.</p>
	<p>Последнее развитие компилятор получил благодаря современной среде разработки TASM Visual. С её помощью работа с компилятором многократно упрощается.</p>
	<p>Пример программы для MS-DOS на TASM</p>
		            <p class="pic"><img src="Multimedia/TASM.jpg" align="center" size="325" height="325" title="" /></p>
	<p>Пример программы для MS-DOS на TASM (тот же пример в режиме IDEAL)</p>
	 				<p class="pic"><img src="Multimedia/TASM2.jpg" align="center" size="325" height="325" title="" /></p>
	<p>Еще пример программы для MS-DOS на TASM (с описанием)</p>
					<p class="pic"><img src="Multimedia/TASM3.jpg" align="center" size="325" height="325" title="" /></p>
		<h1>SASM</h1>
	<p>SASM (SimpleASM) — бесплатная простая кроссплатформенная Open Source среда разработки программного обеспечения на языках ассемблера NASM, MASM, GAS, FASM с подсветкой синтаксиса и отладчиком.</p>
	<p>SASM позволяет легко разрабатывать и выполнять программы, написанные на языке ассемблера. Программа работает «из коробки» и хорошо подходит для начинающих изучать язык ассемблера.</p>
	<p>Основана на Qt. Распространяется по свободной лицензии GNU GPL v3.0.</p>
	<p>Создана программистом Дмитрием Манушиным (Dman95)</p>
		<p>Возможности</p>



	</div>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="script.js"></script>
</body>
</html>